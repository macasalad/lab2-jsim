*******************************************************************************
* LAB #2
* - Baniqued, Hannah Lei
* - Gonzales, Robynne Alexa
* - Paderna, Mikaela
*******************************************************************************
.include "8clocks.jsim"
.include "nominal.jsim"
.include "stdcell.jsim"
*******************************************************************************

*******************************************************************************
* Subcircuit: fx_orig
* Equation implemented: OUT = ABC + DE + FG
* Notes:
*   - Inputs:  a, b, c, d, e, f, g
*   - Output:  fx_orig_out
*   - Logic:
*       Xand1: computes ABC
*       Xand2: computes DE
*       Xand3: computes FG
*       Xor1: combines all three products into the final output
*   - This implementation directly follows the original given equation
*     without any algebraic manipulation or gate transformation.
*******************************************************************************
.subckt fx_orig a b c d e f g fx_orig_out
    Xand1 a b c out_1 and3
    Xand2 d e out_2 and2
    Xand3 f g out_3 and2
    Xor1 out_1 out_2 out_3 fx_orig_out or3
.ends

*******************************************************************************
* Subcircuit: fx
* Equation implemented: OUT = ![!(ABC)!(DE)!(FG)]
* This equation was derived from the original equation:
* OUT = ABC + DE + FG        // Original Equation
* OUT = ![!(ABC + DE + FG)]  // Applying Double Negation
* OUT = ![!(ABC)!(DE)!(FG)]  // Applying De Morgan's Law
* Notes:
*   - Inputs:  a, b, c, d, e, f, g
*   - Output:  fx_nand_out
*   - Logic:
*       Xnand1: computes !(ABC)
*       Xnand2: computes !(DE)
*       Xnand3: computes !(FG)
*       Xnand4: computes ![!(ABC)!(DE)!(FG)]
*   - Implemented entirely with NAND gates
*   - NAND gates are preferred in practice because they are more 
*     efficient and cost-friendly to fabricate.
*******************************************************************************
.subckt fx a b c d e f g fx_out
    Xnand1 a b c out_1 nand3
    Xnand2 d e out_2 nand2
    Xnand3 f g out_3 nand2
    Xnand4 out_1 out_2 out_3 fx_out nand3
.ends

*****************************************************************************
* The original circuit (fx_orig) uses three AND gates that feed into one OR gate.
* The plot window shows that this design has longer propagation delays.
* Since the critical path passes through two different types of gates, this stacking
* increases the propagation delay. 
*
* Meanwhile, the final circuit (fx) only uses one type of gate: NAND gates.
* NAND is a universal gate and is more efficient in CMOS implementations. 
* Compared to mixing AND and OR gates, using only NAND gates is more uniform and
* seems to allow for faster switching. 
* Hence, the propagation delays are shorter than that of fx_orig.
* 
* The plot window confirms shorter propagation delays for fx compared to fx_orig,
* proving that fx achieves the same Boolean function at a better speed. 
* Therefore, we submit fx as the final circuit because it is more efficient and
* optimized for NAND-based logic. 
*******************************************************************************

*******************************************************************************
* The full adder circuit equation that adds three bits can be derived from its truth table.
* First, full adder logic shows that sum only becomes 1 when an odd number of inputs is 1.
* Therefore, the equation A XOR B XOR C_in can be derived for getting the sum.
* Next, the equation for C_out can be expressed in Sum-of-Products form:
* C_out = !ABC_in + A!BC_in + AB!C_in + ABC_in
* We can now simplify it as such:
* C_out = !ABC_in + A!BC_in + AB(!C_in + C_in)
* C_out = !ABC_in + A!BC_in + AB(1)
* C_out = C_in(!AB + A!B) + AB
* C_out = C_in(A XOR B) + AB
* This is now the basis for implementing the following subcircuit: 
* Subcircuit: fa_orig
* Notes:
*    - Inputs:  a, b, c_in
*    - Output:  sum_orig, c_out_orig
*    - Logic:
*        Xxor1: computes A XOR B
*        Xxor2: computes (A XOR B) XOR C_in
*        Xand1: computes AB
*        Xand2: computes (A XOR B)C_in
*        Xor1: computes (AB) + [C_in(A XOR B)]
*****************************************************************************

.subckt fa_orig a b c_in sum_orig c_out_orig
    Xxor1 a b sum_1 xor2
    Xxor2 sum_1 c_in sum_orig xor2
    Xand1 a b c_out1 and2
    Xand2 c_in sum_1 c_out2 and2
    Xor1 c_out1 c_out2 c_out_orig or2
.ends

*****************************************************************************
* Subcircuit: fa
* Equation implemented:
* SUM = A XOR B XOR C
* C_out = ![!(AB)![(A XOR B)C_in]]
* The sum equation remains the same, but the C_out equation was derived as follows:
* C_out = AB + (A XOR B)C_in
* C_out = !![AB + (A XOR B)C_in] // Applying Double Negation
* C_out = ![!(AB)![(A XOR B)C_in]] // Applying De Morgan's Law
* Notes:
*    - Inputs:  a, b, c_in
*    - Output:  sum, c_out
*    - Logic:
*        Xxor1: computes A XOR B
*        Xxor2: computes (A XOR B) XOR C_in
*        Xnand1: computes !(AB)
*        Xnand2: computes ![C_in(A XOR B)]
*        Xnand3: computes ![!(AB)![(A XOR B)C_in]]
*****************************************************************************

.subckt fa a b c_in sum c_out
    Xxor1 a b sum_1 xor2
    Xxor2 sum_1 c_in sum xor2
    Xnand1 a b c_out1 nand2
    Xnand2 c_in sum_1 c_out2 nand2
    Xnand3 c_out1 c_out2 c_out nand2
.ends

*******************************************************************************
* Subcircuit: fa_nand
* Note that:
*   SUM = A XOR B = ![!(A!(AB))!(B!(AB))] (https://www.tutorialspoint.com/digital-electronics/implementation-of-xor-gate-from-nand-gate.htm)
*   We can let Y = ![!(A!(AB))!(B!(AB))]
*   Thus, (A XOR B) XOR C_IN = Y XOR C_IN
*   Moreover, C_OUT = AB + C_IN(A XOR B)
*   C_OUT = AB + C_IN(Y)
*
* Notes:
*   - Inputs:  a, b, c_in
*   - Outputs: sum_nand, c_out_nand
*   - Logic:
*       Xnand1: computes !(AB)
*       Xnand2: computes !(A!(AB))
*       Xnand3: computes !(B!(AB))
*       Xnand4: computes ![!(A!(AB))!(B!(AB))], which is our Y = A XOR B
*       Xnand5: computes !(Y C_in)
*       Xnand6: computes !(Y!(Y C_in))
*       Xnand7: computes !(C_in!(Y C_in))
*       Xnand8: computes ![!(Y!(Y C_in))!(C_in!(Y C_in))], which is Y XOR C_in,
*               equal to SUM = A XOR B XOR C_in
*       Xnand9: computes ![!(AB)!(Y C_in)], which is the carry_out,
*               C_OUT = ![!(AB)!((A XOR B)(C_in))]
*   - Overall, the circuit uses 9 NAND gates
*******************************************************************************
.subckt fa_nand a b c_in sum_nand c_out_nand
    Xnand1 a b nand_1 nand2
    Xnand2 a nand_1 nand_2 nand2
    Xnand3 b nand_1 nand_3 nand2
    Xnand4 nand_2 nand_3 a_xor_b nand2

    Xnand5 a_xor_b c_in nand_5 nand2
    Xnand6 a_xor_b nand_5 nand_6 nand2
    Xnand7 c_in nand_5 nand_7 nand2
    Xnand8 nand_6 nand_7 sum_nand nand2

    Xnand9 nand_1 nand_5 c_out_nand nand2
.ends

***************************************************************************
* The original circuit (fa_orig) uses two XOR gates, two AND gates, and one OR gate.
* The second circuit (fa) uses two XOR gates and three NAND gates.
* The third circuit (fa_nand) uses nine NAND gates.
* The first circuit performs the least efficiently due to its use of AND gates and OR gates.
* It can also be seen as it has the longest propagation delays in the plot among the three.
* Then, the remaining two circuits are much more efficient due to their use of NAND gates.
* Despite some variances, it can be observed that fa_nand has faster propagation delays than fa.
* This makes sense because NAND gates are generally the most efficient gates in CMOS implementations.
* However, it is important to note that fa_nand uses nine gates in total, while fa only uses five.
* While propagation delays do play a factor in efficiency, they matter less than the number of gates used.
* Although fa_nand achieves lower propagation delay, it also costs nearly twice as much gates.
* Minimizing gate count leads to a more practical and efficient design overall.
* Thus, we submit fa as our final circuit.
*****************************************************************************

*******************************************************************************
* Circuit Instantiations
*******************************************************************************
Xfx_orig clk1 clk2 clk3 clk4 clk5 clk6 clk7 fx_orig_out fx_orig
Xfx clk1 clk2 clk3 clk4 clk5 clk6 clk7 fx_out fx
Xfa_orig clk5 clk6 clk7 sum_orig c_out_orig fa_orig
Xfa clk5 clk6 clk7 sum c_out fa
Xfa_nand clk5 clk6 clk7 sum_nand c_out_nand fa_nand

*******************************************************************************
* Transient Analysis, Input Clock Signals, and Output Signals
*******************************************************************************
.tran 640ns
.plot clk1
.plot clk2
.plot clk3
.plot clk4
.plot clk5
.plot clk6
.plot clk7
.plot fx_orig_out
.plot fx_out
.plot sum_orig
.plot sum
.plot sum_nand
.plot c_out_orig
.plot c_out
.plot c_out_nand